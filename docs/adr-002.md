# ADR-002: Embedded Struct Support in Unmarshaler

**Status**: Implemented

This document outlines the design for adding support for anonymous embedded
structs to the MAML unmarshaler.

## Guiding Principles

1. Idiomatic Go: The behavior should align with the established conventions
   of Go's standard `encoding` packages, particularly `encoding/json`, to meet
   developer expectations.
2. Clarity and Predictability: The rules for field precedence and name
   resolution must be clear and deterministic.
3. Minimal API Change: This feature should be an enhancement to the existing
   `Unmarshal` logic and should not require any changes to the public API
   signature.

## Problem Context

Go's struct embedding allows fields and methods of an anonymous inner struct to
be "promoted" to the outer struct. This is a common pattern for composition. For
an `encoding` library to feel idiomatic, it must support this feature.

Currently, the `mapper` only inspects the fields declared directly on a given
struct type. It does not traverse into embedded structs.

**Example:**

```go
type Address struct {
    City string
}

type User struct {
    Name string
    Address // Embedded struct
}
```

Given the MAML input `{ Name: "John", City: "London" }`, a user would expect
`Unmarshal` to correctly populate both `user.Name` and `user.Address.City`. The
current implementation would only populate `Name` and would ignore `City`.

## Decision

We will enhance the `mapper` to support unmarshaling into anonymous embedded
structs. The implementation will follow the field precedence rules of the
standard `encoding/json` package.

This includes support for both value (`Address`) and pointer (`*Address`)
embedded structs.

## Implementation Details

The core of this work will be in the `mapper/field.go` file, specifically within
the `cachedFields` function.

### 1. Recursive Field Discovery

The `cachedFields` function will be modified to recursively scan for fields.
When it encounters an anonymous (`sf.Anonymous`) and embedded struct field, it
will:

1. Traverse into that struct type (handling both value and pointer types).
2. Recursively call `cachedFields` on the embedded type to get its fields.
3. Add the fields from the embedded struct to the parent's field map, adjusting
   their `idx` path to include the index of the embedded struct field itself.

### 2. Field Precedence and Shadowing

To handle name collisions, we will adopt the same rules as `encoding/json`:

1. Fields at a shallower depth take precedence. A field `Name` on the `User`
   struct will always be chosen over a field `Name` on an embedded `Address`
   struct.
2. When adding fields from an embedded struct to the cache, we will check if a
   field with that name already exists. If it does, we ignore the field from
   the deeper (embedded) struct.

This ensures that the unmarshaling behavior is predictable and that developers
can override embedded fields by declaring them on the outer struct.

### 3. Pointer Handling

The `cachedFields` recursion must correctly handle pointer-to-struct embeds
(e.g., `*Address`). When unmarshaling, the existing pointer indirection logic in
`mapValue` will be responsible for initializing the embedded struct if it is a
nil pointer.

## Example of New Behavior

Given the following Go types:

```go
type Address struct {
    City   string `maml:"city"`
    Street string
}

type User struct {
    Name string
    *Address // Embedded pointer to struct
}
```

And the MAML input:

```maml
{
  Name: "Jane Doe"
  city: "New York"
  Street: "123 Main St"
}
```

The `Unmarshal` call will behave as follows:

```go
var user User
err := maml.Unmarshal(data, &user)

// Result:
// user.Name == "Jane Doe"
// user.Address != nil
// user.Address.City == "New York"  (matched via tag)
// user.Address.Street == "123 Main St" (matched via case-insensitive name)
```
