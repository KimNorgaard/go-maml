# ADR-003: Comment Preservation for Round-Trip Configuration Editing

**Status**: Implemented

This document outlines the design for adding support for preserving comments
when programmatically reading, modifying, and writing MAML files.

## Guiding Principles

1. Preservation as a Priority: For configuration files, comments are a critical
   form of documentation and institutional knowledge. Their accidental removal
   during a programmatic edit should be avoidable.
2. Explicit API: The new functionality should be exposed through a clear, opt-in
   API. The default, simple API (`Marshal`/`Unmarshal`) should remain fast and
   focused on data serialization.
3. Minimal Performance Impact: The common use case of unmarshaling into Go
   structs should not suffer a performance penalty from the addition of this
   feature.

## Problem Context

MAML is a configuration language, and it is expected that configuration files
will be edited by both humans and machines. A common scenario is a program
needing to update a single value in a config file that is otherwise maintained
by a human.

Currently, the library's architecture is focused purely on data serialization.
The `Unmarshal` function parses the MAML syntax, extracts the semantic data into
a Go struct, and discards non-data elements like comments. When the program
later calls `Marshal` on that struct, a new MAML representation is created from
scratch, containing no comments.

**Example of the Problem:**

Given this input `config.maml`:

```maml
# The number of seconds to wait for a connection.
# Must be a positive integer.
timeout: 30

# The user to run the service as.
user: "app_user"
```

A program that updates the timeout value would perform this workflow:

```go
data, _ := os.ReadFile("config.maml")
var cfg MyConfig
maml.Unmarshal(data, &cfg) // Comments are lost here

cfg.Timeout = 60 // Update the value

newData, _ := maml.Marshal(cfg) // A new representation is created
os.WriteFile("config.maml", newData, 0644)
```

The resulting `config.maml` would lose all the valuable comments:

```maml
{
  timeout: 60,
  user: "app_user"
}
```

This is a destructive and undesirable outcome for a configuration file
management tool.

## Decision

We will implement a dual-mode API to support both simple data serialization and
comment-preserving document manipulation. This feature will be **opt-in**.

1. Data Serialization Mode (Default): The existing `Marshal` and `Unmarshal`
   functions will continue to provide a high-performance bridge between MAML and
   native Go types. This API will remain destructive to comments, as is standard
   for `encoding` packages.

2. Document Manipulation Mode (New): We will introduce a new set of functions
   for parsing MAML into a rich Abstract Syntax Tree (AST) that retains
   comments, whitespace, and positional information. Users can then modify this
   AST directly and marshal it back to text, preserving the original formatting
   and comments.

This approach provides a solution for configuration management use cases without
complicating the simple, common case of data serialization.

## Implementation Details

### 1. Lexer and Parser Enhancements

- A new `ParseComments` option will be added.
- When this option is enabled, the `lexer` will be modified to emit
  `token.COMMENT` tokens instead of skipping them.
- The `parser` will be enhanced to consume these `COMMENT` tokens and associate
  them with the relevant AST nodes.

### 2. AST Enrichment

The AST node interfaces will be updated to store comment information. Nodes that
can be commented (e.g., `ObjectLiteral`, `KeyValueExpression`, `ArrayLiteral`)
will gain fields to store associated comments. We will distinguish between
comment positions:

- `HeadComment`: A comment block that appears directly before a node.
- `LineComment`: A comment that appears on the same line as a node.
- `FootComment`: A comment that appears directly after a node, before the next
  sibling.

### 3. New Public API for Document Manipulation

A new set of public functions will be introduced as the entry point for this
mode:

- `maml.Parse(data []byte) (*ast.Document, error)`: This function will parse a
  MAML document into a full, comment-rich AST.
- The `*ast.Document` and its child nodes will be equipped with helper methods
  to facilitate inspection and mutation (e.g., `Find(path string)`, `SetValue(v
  any)`, `SetComment(text string)`).

### 4. Formatter Update

The `formatter` will be updated to inspect the new comment fields on AST nodes.
When writing a node, it will check for associated `HeadComment`, `LineComment`,
and `FootComment` fields and print them in the correct location relative to the
node's own representation.

## Example of New Behavior

This example demonstrates the intended workflow for a user who wants to
programmatically update a configuration file while preserving its comments.

**Input (`config.maml`):**

```maml
# Global application settings
{
  # The number of seconds to wait for a connection.
  timeout: 30,

  user: "app_user" # The user to run as
}
```

**Go Code:**

```go
import "github.com/KimNorgaard/go-maml/internal/ast"

data, _ := os.ReadFile("config.maml")

// Parse into the rich AST, preserving comments
doc, err := maml.Parse(data)
require.NoError(t, err)

// Find the node to modify using a path or other traversal method
timeoutNode, err := ast.Find(doc, "timeout")
require.NoError(t, err)

// Programmatically update the value
timeoutNode.SetValue(60)

// Marshal the modified AST back to bytes
newData, err := maml.Marshal(doc) // Marshal can accept an AST
require.NoError(t, err)

os.WriteFile("config.maml", newData, 0644)
```

**Output (`config.maml`):**

```maml
# Global application settings
{
  # The number of seconds to wait for a connection.
  timeout: 60,

  user: "app_user" # The user to run as
}
```

The timeout value is updated, and all original comments and formatting are
preserved.
